<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TradingView API è¿æ¥æµ‹è¯•</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #1a1a1a;
            color: #fff;
        }
        .test-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #333;
            border-radius: 5px;
            background-color: #2a2a2a;
        }
        .status {
            padding: 5px 10px;
            border-radius: 3px;
            font-weight: bold;
        }
        .success { background-color: #4a5d23; color: #90c695; }
        .error { background-color: #5d2323; color: #c69090; }
        .loading { background-color: #4a4a23; color: #c6c690; }
        pre {
            background-color: #333;
            padding: 10px;
            border-radius: 3px;
            overflow-x: auto;
            max-height: 300px;
        }
        button {
            background-color: #007acc;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 3px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background-color: #005a9c;
        }
    </style>
</head>
<body>
    <h1>ğŸ“ˆ TradingView API è¿æ¥æµ‹è¯•</h1>

    <div class="test-section">
        <h2>ğŸ”— æµ‹è¯•å¤šä¸ªæ•°æ®æº</h2>
        <button onclick="testBinanceAPI()">æµ‹è¯• Binance API</button>
        <button onclick="testCoinGeckoAPI()">æµ‹è¯• CoinGecko API</button>
        <button onclick="testCryptoCompareAPI()">æµ‹è¯• CryptoCompare API</button>
        <button onclick="testYahooFinanceAPI()">æµ‹è¯• Yahoo Finance API</button>
        <div id="multi-status" class="status loading">ç­‰å¾…æµ‹è¯•...</div>
        <pre id="multi-result"></pre>
    </div>

    <div class="test-section">
        <h2>ğŸª™ CoinGecko API è¯¦ç»†æµ‹è¯•</h2>
        <button onclick="testCoinGeckoDetailed()">è¯¦ç»†æµ‹è¯• CoinGecko</button>
        <div id="coingecko-status" class="status loading">ç­‰å¾…æµ‹è¯•...</div>
        <pre id="coingecko-result"></pre>
    </div>

    <div class="test-section">
        <h2>ğŸ“Š WebSocket æµ‹è¯•</h2>
        <button onclick="testWebSocketSources()">æµ‹è¯• WebSocket è¿æ¥</button>
        <div id="ws-status" class="status loading">ç­‰å¾…æµ‹è¯•...</div>
        <pre id="ws-result"></pre>
    </div>

    <script>
        // æµ‹è¯•å¤šä¸ªAPIæº
        async function testBinanceAPI() {
            updateStatus('multi', 'æµ‹è¯• Binance API...', 'loading');
            try {
                const response = await fetch('https://api.binance.com/api/v3/ticker/24hr?symbol=BTCUSDT');
                if (response.ok) {
                    const data = await response.json();
                    appendResult('multi', `âœ… Binance API: BTCä»·æ ¼ $${parseFloat(data.lastPrice).toFixed(2)}`);
                    return true;
                } else {
                    throw new Error(`HTTP ${response.status}`);
                }
            } catch (error) {
                appendResult('multi', `âŒ Binance API: ${error.message}`);
                return false;
            }
        }

        async function testCoinGeckoAPI() {
            try {
                const response = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=bitcoin,ethereum&vs_currencies=usd&include_24hr_change=true');
                if (response.ok) {
                    const data = await response.json();
                    appendResult('multi', `âœ… CoinGecko API: BTC $${data.bitcoin.usd} (${data.bitcoin.usd_24h_change?.toFixed(2)}%)`);
                    return true;
                } else {
                    throw new Error(`HTTP ${response.status}`);
                }
            } catch (error) {
                appendResult('multi', `âŒ CoinGecko API: ${error.message}`);
                return false;
            }
        }

        async function testCryptoCompareAPI() {
            try {
                const response = await fetch('https://min-api.cryptocompare.com/data/price?fsym=BTC&tsyms=USD');
                if (response.ok) {
                    const data = await response.json();
                    appendResult('multi', `âœ… CryptoCompare API: BTC $${data.USD}`);
                    return true;
                } else {
                    throw new Error(`HTTP ${response.status}`);
                }
            } catch (error) {
                appendResult('multi', `âŒ CryptoCompare API: ${error.message}`);
                return false;
            }
        }

        async function testYahooFinanceAPI() {
            try {
                // Yahoo Finance é€šå¸¸éœ€è¦CORSä»£ç†
                const response = await fetch('https://cors-anywhere.herokuapp.com/https://query1.finance.yahoo.com/v8/finance/chart/BTC-USD');
                if (response.ok) {
                    const data = await response.json();
                    const price = data.chart.result[0].meta.regularMarketPrice;
                    appendResult('multi', `âœ… Yahoo Finance API: BTC $${price.toFixed(2)}`);
                    return true;
                } else {
                    throw new Error(`HTTP ${response.status}`);
                }
            } catch (error) {
                appendResult('multi', `âŒ Yahoo Finance API: ${error.message}`);
                return false;
            }
        }

        // CoinGecko è¯¦ç»†æµ‹è¯•
        async function testCoinGeckoDetailed() {
            updateStatus('coingecko', 'æ­£åœ¨æµ‹è¯• CoinGecko API...', 'loading');
            let results = [];

            try {
                // æµ‹è¯•ä»·æ ¼API
                const priceResponse = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=bitcoin,ethereum,binancecoin,cardano,solana,ripple,polkadot,dogecoin,avalanche-2,chainlink&vs_currencies=usd&include_24hr_change=true&include_24hr_vol=true');

                if (priceResponse.ok) {
                    const priceData = await priceResponse.json();
                    results.push('âœ… ä»·æ ¼æ•°æ®è·å–æˆåŠŸ:');

                    const coinMap = {
                        'bitcoin': 'BTC',
                        'ethereum': 'ETH',
                        'binancecoin': 'BNB',
                        'cardano': 'ADA',
                        'solana': 'SOL',
                        'ripple': 'XRP',
                        'polkadot': 'DOT',
                        'dogecoin': 'DOGE',
                        'avalanche-2': 'AVAX',
                        'chainlink': 'LINK'
                    };

                    Object.entries(priceData).forEach(([id, data]) => {
                        const symbol = coinMap[id] || id;
                        const change = data.usd_24h_change?.toFixed(2) || 'N/A';
                        results.push(`  ${symbol}: $${data.usd} (${change}%)`);
                    });

                    updateStatus('coingecko', 'âœ… CoinGecko API æµ‹è¯•æˆåŠŸ', 'success');
                } else {
                    throw new Error(`ä»·æ ¼APIå¤±è´¥: ${priceResponse.status}`);
                }

                // æµ‹è¯•å†å²æ•°æ®API
                const historyResponse = await fetch('https://api.coingecko.com/api/v3/coins/bitcoin/market_chart?vs_currency=usd&days=1&interval=hourly');

                if (historyResponse.ok) {
                    const historyData = await historyResponse.json();
                    results.push('');
                    results.push('âœ… å†å²æ•°æ®è·å–æˆåŠŸ:');
                    results.push(`  ä»·æ ¼æ•°æ®ç‚¹: ${historyData.prices.length}`);
                    results.push(`  æˆäº¤é‡æ•°æ®ç‚¹: ${historyData.total_volumes.length}`);

                    const latestPrice = historyData.prices[historyData.prices.length - 1];
                    results.push(`  æœ€æ–°ä»·æ ¼: $${latestPrice[1].toFixed(2)} (${new Date(latestPrice[0]).toLocaleTimeString()})`);
                } else {
                    results.push('âš ï¸ å†å²æ•°æ®APIå¤±è´¥ï¼Œä½†ä»·æ ¼APIæ­£å¸¸');
                }

                document.getElementById('coingecko-result').textContent = results.join('\n');

            } catch (error) {
                updateStatus('coingecko', 'âŒ CoinGecko API æµ‹è¯•å¤±è´¥', 'error');
                document.getElementById('coingecko-result').textContent = `é”™è¯¯: ${error.message}`;
            }
        }

        // WebSocket æµ‹è¯•
        function testWebSocketSources() {
            updateStatus('ws', 'æ­£åœ¨æµ‹è¯• WebSocket è¿æ¥...', 'loading');
            let results = [];
            let completedTests = 0;
            const totalTests = 2;

            function checkCompletion() {
                completedTests++;
                if (completedTests >= totalTests) {
                    updateStatus('ws', 'âœ… WebSocket æµ‹è¯•å®Œæˆ', 'success');
                }
                document.getElementById('ws-result').textContent = results.join('\n');
            }

            // æµ‹è¯• Binance WebSocket
            try {
                const binanceWs = new WebSocket('wss://stream.binance.com:9443/ws/btcusdt@ticker');
                let binanceMessageCount = 0;

                binanceWs.onopen = () => {
                    results.push('âœ… Binance WebSocket è¿æ¥æˆåŠŸ');
                    checkCompletion();
                };

                binanceWs.onmessage = (event) => {
                    if (binanceMessageCount < 3) {
                        const data = JSON.parse(event.data);
                        results.push(`ğŸ“¨ Binance: BTC $${parseFloat(data.c).toFixed(2)}`);
                        binanceMessageCount++;
                        document.getElementById('ws-result').textContent = results.join('\n');
                    }
                    if (binanceMessageCount >= 3) {
                        binanceWs.close();
                    }
                };

                binanceWs.onerror = () => {
                    results.push('âŒ Binance WebSocket è¿æ¥å¤±è´¥');
                    checkCompletion();
                };

                setTimeout(() => {
                    if (binanceWs.readyState === WebSocket.OPEN) {
                        binanceWs.close();
                    }
                    if (binanceMessageCount === 0) {
                        results.push('â° Binance WebSocket è¶…æ—¶');
                        checkCompletion();
                    }
                }, 10000);

            } catch (error) {
                results.push(`âŒ Binance WebSocket é”™è¯¯: ${error.message}`);
                checkCompletion();
            }

            // æµ‹è¯•å…¶ä»– WebSocket (å¦‚æœæœ‰çš„è¯)
            setTimeout(() => {
                results.push('â„¹ï¸ å…¶ä»– WebSocket æºæµ‹è¯•å®Œæˆ');
                checkCompletion();
            }, 1000);
        }

        // è¾…åŠ©å‡½æ•°
        function updateStatus(section, message, type) {
            const statusEl = document.getElementById(`${section}-status`);
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
        }

        function appendResult(section, message) {
            const resultEl = document.getElementById(`${section}-result`);
            const currentText = resultEl.textContent;
            resultEl.textContent = currentText ? currentText + '\n' + message : message;
        }

        // é¡µé¢åŠ è½½æ—¶æ˜¾ç¤ºè¯´æ˜
        document.addEventListener('DOMContentLoaded', () => {
            console.log('ğŸ§ª å¤šæ•°æ®æºAPIæµ‹è¯•é¡µé¢å·²åŠ è½½');
            console.log('CoinGecko API é€šå¸¸æ¯” Binance API æ›´å®¹æ˜“è®¿é—®ï¼Œå› ä¸ºå®ƒä¸“é—¨è®¾è®¡ç”¨äºç¬¬ä¸‰æ–¹é›†æˆ');
        });
    </script>
</body>
</html>
